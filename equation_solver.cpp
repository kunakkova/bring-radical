#include <iostream>
#include <cmath>
#include <utility>

// Функция f(x) = x^5 + x + a
// Принимает:
//   x - точка, в которой вычисляется функция
//   a - параметр уравнения
// Возвращает значение функции в точке x
double f(double x, double a) {
    return std::pow(x, 5) + x + a;
}

// Производная функции f'(x) = 5x^4 + 1
// Принимает:
//   x - точка, в которой вычисляется производная
// Возвращает значение производной в точке x
double df(double x) {
    return 5 * std::pow(x, 4) + 1;
}

// Нахождение интервала [left, right], где f(left) * f(right) < 0
// (интервал, содержащий корень, по теореме о промежуточном значении)
// Принимает:
//   a - параметр уравнения
// Возвращает пару значений (left, right) - границы интервала
std::pair<double, double> find_interval(double a) {
    if (a >= 0) {
        // Для неотрицательных a корень находится в отрицательной области
        double left = -2; // Начальное значение левой границы
        // Удваиваем left, пока функция не станет отрицательной
        while (f(left, a) >= 0) {
            left *= 2;
        }
        // Правая граница - 0, так как f(0) = a >= 0
        return {left, 0};
    } else {
        // Для отрицательных a корень находится в положительной области
        double right = 1; // Начальное значение правой границы
        // Удваиваем right, пока функция не станет положительной
        while (f(right, a) <= 0) {
            right *= 2;
        }
        // Левая граница - 0, так как f(0) = a < 0
        return {0, right};
    }
}

// Метод бисекции для нахождения корня уравнения
// Принимает:
//   a - параметр уравнения
//   left, right - границы интервала, содержащего корень
//   epsilon - требуемая точность
void bisection(double a, double left, double right, double epsilon) {
    int iter = 0; // Счетчик итераций
    // Продолжаем, пока длина интервала больше заданной точности
    while (right - left > epsilon) {
        double mid = (left + right) / 2; // Середина интервала
        double f_mid = f(mid, a); // Значение функции в середине
        std::cout << "Бисекция, итерация " << iter << ": mid = " << mid << ", f(mid) = " << f_mid << std::endl;
        
        // Если нашли точный корень (маловероятно для чисел с плавающей точкой)
        if (f_mid == 0) {
            std::cout << "Точный корень найден: " << mid << std::endl;
            return;
        }
        
        // Выбираем новую границу в зависимости от знака функции
        if (f_mid * f(left, a) < 0) {
            right = mid; // Корень в левой половине
        } else {
            left = mid; // Корень в правой половине
        }
        iter++;
        
        // Защита от бесконечного цикла
        if (iter > 1000) {
            std::cerr << "Бисекция: превышено максимальное число итераций!" << std::endl;
            break;
        }
    }
    // Возвращаем середину последнего интервала как приближенный корень
    double root = (left + right) / 2;
    std::cout << "Метод бисекции: корень = " << root << ", f(root) = " << f(root, a) << std::endl;
}

// Метод Ньютона для нахождения корня уравнения
// Принимает:
//   a - параметр уравнения
//   x0 - начальное приближение
//   epsilon - требуемая точность
void newton(double a, double x0, double epsilon) {
    double x = x0; // Текущее приближение
    double delta = 1; // Разница между приближениями
    int iter = 0; // Счетчик итераций
    // Продолжаем, пока изменение больше заданной точности
    while (std::abs(delta) > epsilon) {
        double fx = f(x, a); // Значение функции
        double dfx = df(x); // Значение производной
        
        // Проверка на слишком малую производную (может привести к делению на 0)
        if (std::abs(dfx) < 1e-10) {
            std::cerr << "Производная близка к нулю! Метод Ньютона не может продолжаться." << std::endl;
            break;
        }
        
        delta = fx / dfx; // Вычисляем поправку
        x -= delta; // Обновляем приближение
        std::cout << "Ньютон, итерация " << iter << ": x = " << x << ", f(x) = " << f(x, a) << std::endl;
        iter++;
        
        // Защита от бесконечного цикла
        if (iter > 1000) {
            std::cerr << "Метод Ньютона: превышено максимальное число итераций!" << std::endl;
            break;
        }
    }
    std::cout << "Метод Ньютона: корень = " << x << ", f(root) = " << f(x, a) << std::endl;
}

int main() {
    double a;
    std::cout << "Введите a: ";
    std::cin >> a;

    // Находим интервал, содержащий корень
    auto [left, right] = find_interval(a);
    double epsilon = 1e-10; // Точность вычислений

    std::cout << "Интервал: [" << left << ", " << right << "]" << std::endl;

    // Начальное приближение для метода Ньютона (середина интервала)
    double x0 = (left + right) / 2;
    std::cout << "Начальное приближение для Ньютона: " << x0 << std::endl;

    // Выполняем оба метода для сравнения
    bisection(a, left, right, epsilon);
    newton(a, x0, epsilon);

    return 0;
}
